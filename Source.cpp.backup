#include <stdio.h>
#include "scrollMaster.h"

using namespace ScrollMaster;
ScrollHook *ScrollHook::instance = nullptr;


//KBDLLHOOKSTRUCT *kbh;
//bool gb_pressed = false;
//bool gb_isbreak = false;
//
//void SendCustomInput(bool mouse)
//{
//	INPUT input[1];
//
//	if (mouse == true) {
//		/* Send the scroll input */
//		input[0].type = INPUT_MOUSE;
//		input[0].mi.dx = 0;
//		input[0].mi.dy = 0;
//		if (gb_pressed)
//			input[0].mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MIDDLEDOWN | MOUSEEVENTF_MIDDLEUP;
//		else
//			input[0].mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP;
//		input[0].mi.mouseData = 0;
//		input[0].mi.dwExtraInfo = NULL;
//		input[0].mi.time = 0;
//		SendInput(1, input, sizeof(INPUT));
//	} else {
//		input[0].type = INPUT_KEYBOARD;
//		input[0].ki.wScan = 0;
//		input[0].ki.time = 0;
//		input[0].ki.dwExtraInfo = 0;
//		input[0].ki.wVk = VK_CONTROL;
//		input[0].ki.dwFlags = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP;
//		SendInput(1, input, sizeof(INPUT));
//
//		input[0].type = INPUT_KEYBOARD;
//		input[0].ki.wScan = 0;
//		input[0].ki.time = 0;
//		input[0].ki.dwExtraInfo = 0;
//		//input[0].ki.wVk = SCROLL_ACTION;
//		input[0].ki.wVk = 0xc0;
//		input[0].ki.dwFlags = KEYEVENTF_UNICODE;
//		SendInput(1, input, sizeof(INPUT));
//
//		input[0].ki.dwFlags = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP;
//		SendInput(1, input, sizeof(INPUT));
//	}
//}
//
//LRESULT CALLBACK SetScrollHook(int nCode, WPARAM wParam, LPARAM lParam)
//{
//	kbh = (KBDLLHOOKSTRUCT *)lParam;
//	if (!kbh)
//		return CallNextHookEx(NULL, nCode, wParam, lParam);
//
//	if (gb_isbreak) {
//		gb_isbreak = false;
//		return 1;
//	}
//
//	//printf("%x\n", kbh->scanCode);
//	//printf("%x\n", kbh->flags);
//
//	if (kbh->vkCode == SCROLL_ACTION) {
//		switch (wParam) {
//		case WM_KEYDOWN:
//			/* Ignore repeated key signals - duplicate key presses will exit out of the "middle click"
//			   scroll functionality in some apps like web browsers */
//			if (gb_pressed == true) {
//				break;
//			}
//			/* Hold either control button before pressing SCROLL_ACTION to "free" it from its
//			   scroll behavior - this allows you to actually use the key */
//			if (ISBREAK) {
//				//printf("free key\n");
//				gb_isbreak = true;
//				SendCustomInput(false);
//				//printf("%x", kbh->vkCode);
//				break;
//			}
//			gb_pressed = true;
//			SendCustomInput(true);
//			break;
//		case WM_KEYUP:
//			if (gb_pressed == true) {
//				gb_pressed = false;
//				SendCustomInput(true);
//			}
//			break;
//		default:
//			break;
//		}
//
//		return 1;
//	}
//
//	return CallNextHookEx(NULL, nCode, wParam, lParam);
//}
//
//DWORD WINAPI ScrollThread()
//{
//	HHOOK handle = SetWindowsHookEx(WH_KEYBOARD_LL, SetScrollHook, NULL, 0);
//	if (!handle) {
//		printf("Couldn't hook mouse\n");
//		return -1;
//	}
//	printf("Successfully hooked from main .exe\n");
//
//	MSG message;
//	while (GetMessageW(&message, NULL, 0, 0)) {
//		TranslateMessage(&message);
//		DispatchMessageW(&message);
//	}
//
//	UnhookWindowsHookEx(handle);
//
//	return 0;
//}

int main(int argc, TCHAR *argv[])
{
	ScrollHook *g_hook = ScrollHook::getInstance();
	g_hook->ScrollThread();

	return 0;
}